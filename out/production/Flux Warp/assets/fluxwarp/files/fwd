print("loading...")

-- set alarm side if you need this
Alarm = "top"

Style = {
 CDeflt = colors.white,
 BGDeflt = colors.blue,
 CTitle = colors.black,
 BGTitle = colors.cyan,
 CWarn = colors.white,
 BGWarn = colors.red
}

function SetColorDeflt()
 term.setBackgroundColor(Style.BGDeflt)
 term.setTextColor(Style.CDeflt)
end

function SetColorTitle()
 term.setBackgroundColor(Style.BGTitle)
 term.setTextColor(Style.CTitle)
end

function SetColorWarn()
 term.setBackgroundColor(Style.BGWarn)
 term.setTextColor(Style.CWarn)
end

function Clear()
 term.clear()
 term.setCursorPos(1,1)
end

function Show(Text)
 term.write(Text)
 local xt,yt = term.getCursorPos()
 term.setCursorPos(1, yt+1)
end

function ShowTitle(Text)
 SetColorTitle()
 term.setCursorPos(12, 1)
 Show(Text)
 SetColorDeflt()
end

function ShowMenu(Text)
 term.write(Text)
 local xt, yt = term.getCursorPos()
 for i = xt, 51 do
  term.write(" ")
 end
 term.setCursorPos(1, yt+1)
end

function ShowWarning(Text)
  SetColorWarn()
  term.setCursorPos(10, 19)
  term.write(" "..Text.." ")
  SetColorDeflt()
end

function SaveData()
 local file = fs.open("shipdata.txt", "w")
 file.writeLine(textutils.serialize(SData))
 file.close()
end

function ReadData()
 local file = fs.open("shipdata.txt", "r")
 SData = textutils.unserialize(file.readAll())
 file.close()
end

function Explode(d, p)
 local t, ll
 t = {}
 ll = 0
 if(#p == 1) then return {p} end
 while true do
  l = string.find(p ,d, ll, true)
  if l ~= nil then 
   table.insert(t, string.sub(p, ll, l-1))
   ll = l+1
  else
   table.insert(t, string.sub(p, ll))
   break
  end
 end
 return t
end

function ShowDirection()
 if SData.Direction == 1 then
  Show(" Direction        = Up")
 elseif SData.Direction == 2 then
  Show(" Direction        = Down")
 elseif SData.Direction == 0 then
  Show(" Direction        = Front")
 elseif SData.Direction == 180 then
  Show(" Direction        = Back")
 elseif SData.Direction == 90 then
  Show(" Direction        = Left")
 elseif SData.Direction == 255 then
  Show(" Direction        = Right")
 end
end

function CalcRealDistance()
  RealDistance = SData.Distance
  MinimumDistance = 0
  JumpCost = 1
-- if IsInHyper then
--  RealDistance = SData.Distance * 100
--  MinimumDistance = 1
--  JumpCost = (1000 * Weight) + (1000 * SData.Distance)
-- else
--  if SData.Direction == 1 or SData.Direction == 2 then
--   MinimumDistance = GUp + GDown
--   RealDistance = SData.Distance + MinimumDistance
--  elseif SData.Direction == 0 or SData.Direction == 180 then
--   MinimumDistance = GFront + GBack
--   RealDistance = SData.Distance + MinimumDistance
--  elseif SData.Direction == 90 or SData.Direction == 255 then
--   MinimumDistance = GLeft + GRight
--   RealDistance = SData.Distance + MinimumDistance
--  end
--  MinimumDistance = MinimumDistance + 1
--  JumpCost = (10 * Weight) + (100 * SData.Distance)
-- end
end

function CalcNewCoords(cx, cy, cz)
 local res = {x=cx, y=cy, z=cz}
 if SData.Direction == 1 then
  res.y = res.y + RealDistance
 elseif SData.Direction == 2 then
  res.y = res.y - RealDistance
 end
 local dx, dy, dz = warp.getWarpVector() --.get_dx()
 --local dz = warp.get_dz()
 if dx ~= 0 then
  if SData.Direction == 0 then
   res.x = res.x + (RealDistance * dx)
  elseif SData.Direction == 180 then
   res.x = res.x - (RealDistance * dx)
  elseif SData.Direction == 90 then
   res.z = res.z + (RealDistance * dx)
  elseif SData.Direction == 255 then
   res.z = res.z - (RealDistance * dx)
  end
 else
  if SData.Direction == 0 then
   res.z = res.z + (RealDistance * dz)
  elseif SData.Direction == 180 then
   res.z = res.z - (RealDistance * dz)
  elseif SData.Direction == 90 then
   res.x = res.x + (RealDistance * dz)
  elseif SData.Direction == 255 then
   res.x = res.x - (RealDistance * dz)
  end
 end
 return res
end

function ShowInfo()
 ShowTitle(Title)
 Show("Core:")
 Show(" x, y, z          = "..X..", "..Y..", "..Z)
 local energy = warp.getEnergy()
 Show(" Energy           = "..math.floor(100 * energy / warp.getMaxEnergy()).." % ("..energy.."RF)")--math.floor(energy / 1000000).." % ("..energy.."EU)")
 Show(" Attached players = ")--..warp.get_attached_players())
 Show("Dimensions:")
 Show(" Front, Right, Up = "..GFront..", "..GRight..", "..GUp)
 Show(" Back, Left, Down = "..GBack..", "..GLeft..", "..GDown)
 Show(" Size             = "..Weight.." blocks")
 Show("Warp data:")
 ShowDirection()
 local dest = CalcNewCoords(X, Y, Z)
 Show(" Distance         = "..RealDistance.." ("..JumpCost.."EU, "..math.floor(energy/JumpCost).." jumps)")
 Show(" Dest.coordinates = "..dest.x..", "..dest.y..", "..dest.z)
 if SData.Summon then
  Show(" Summon after     = Yes")
 else
  Show(" Summon after     = No")
 end
end

function Confirm()
 ShowWarning("Are you sure? (y/n)")
 local event, keycode = os.pullEvent("key")
 if keycode == 21 then
  return true
 else
  return false
 end
end

function doDirection(dir)
  if dir == 1 then
    warp.setWarpVector(0,1,0)
  elseif dir == 2 then
    warp.setWarpVector(0,-1,0)
  elseif dir == 0 then
    warp.setWarpVector(1,0,0)
  elseif dir == 90 then
    warp.setWarpVector(0,0,-1)
  elseif dir == 255 then
    warp.setWarpVector(0,0,1)
  elseif dir == 180 then
    warp.setWarpVector(-1,0,0)
  end
end

function doDistance(dist)
  wdx,wdy,wdz = warp.getWarpVector()
  --os.pullEvent('key')
  warp.setWarpVector(dist*wdx, dist*wdy, dist*wdz)
  --term.clear()
  --print(dist .. " " .. wdx .. " " .. wdy .. " " .. wdz)
  --os.pullEvent('key')
end

function Warp()
 rs.setOutput(Alarm, false)
 sleep(1)
 doDirection(SData.Direction) --warp.set_direction(SData.Direction)
 doDistance(SData.Distance)
 --if IsInHyper then
 -- warp.set_mode(2)
 --else
 -- warp.set_mode(1)
 --end
 --term.clear()
 --print(warp.getWarpVector())
 --os.pullEvent('key')
 warp.warp()--.do_jump()
end

function SetDistance()
 Clear()
 ShowTitle("<====  Set distance  ====>")
 SData.Distance = 0
 CalcRealDistance()
 MaximumDistance = MinimumDistance + 127
 if IsInHyper then
  term.write("Distance * 100 (min "..MinimumDistance..", max "..MaximumDistance.."): ")
 else
  term.write("Distance (min "..MinimumDistance..", max "..MaximumDistance.."): ")
 end
 sleep(0.3)
 SData.Distance = tonumber(read())
 --term.clear()
 --print(SData.Distance)
 --os.pullEvent('key')
 if SData.Distance == nil then SData.Distance = 1 end
 if SData.Distance < MinimumDistance or SData.Distance > MaximumDistance then
  SData.Distance = 1
  --term.clear()
  --print(SData.Distance)
  --os.pullEvent('key')
  ShowWarning("Wrong distance. Try again.")
  os.pullEvent("key")
  CalcRealDistance()
 else
  if not IsInHyper then
   SData.Distance = SData.Distance - RealDistance
   --term.clear()
   --print(SData.Distance)
   --os.pullEvent('key')
  end
  doDistance(SData.Distance) --warp.set_distance(SData.Distance)
  CalcRealDistance()
 end
end

function SetDirection()
 local drun = true
 while(drun) do
  Clear()
  ShowTitle("<==== Set direction ====>")
  ShowDirection()
  term.setCursorPos(1, 16)
  SetColorTitle()
  ShowMenu("Use directional keys")
  ShowMenu("W/S keys for Up/Down")
  ShowMenu("Enter - confirm")
  SetColorDeflt()
  local event, keycode = os.pullEvent("key")
  if keycode == 200 then
   SData.Direction = 0
  elseif keycode == 17 then
   SData.Direction = 1
  elseif keycode == 203 then
   SData.Direction = 90
  elseif keycode == 205 then
   SData.Direction = 255
  elseif keycode == 208 then
   SData.Direction = 180
  elseif keycode == 31 then
   SData.Direction = 2
  elseif keycode == 28 then
   drun = false
  end
 end
end

function SetDimensions()
 Clear()
 sleep(0.3)
 ShowTitle("<==== Set dimensions ====>")
 term.write(" Front ("..GFront..") : ")
 GFront = tonumber(read())
 term.write(" Right ("..GRight..") : ")
 GRight = tonumber(read())
 term.write(" Up    ("..GUp..") : ")
 GUp = tonumber(read())
 term.write(" Back  ("..GBack..") : ")
 GBack = tonumber(read())
 term.write(" Left  ("..GLeft..") : ")
 GLeft = tonumber(read())
 term.write(" Down  ("..GDown..") : ")
 GDown = tonumber(read())
 term.write("Setting dimensions...")
 warp.setBounds(GFront, GBack, GUp, GDown, GLeft, GRight )
 --warp.dim_setp(GFront, GRight, GUp)
 --warp.dim_setn(GBack, GLeft, GDown)
end

function SetShipName()
 Clear()
 ShowTitle("<==== Set ship name ====>")
 sleep(0.3)
 term.write("Enter ship name: ")
 SData.Shipname = tostring(read())
 os.setComputerLabel(SData.Shipname)
 --warp.set_core_frequency(SData.Shipname)
 SaveData()
 os.reboot()
end

if fs.exists("shipdata.txt") then
 ReadData()
else
 SData = {
  Summon = false,
  Distance = 1,
  Direction = 0,
  Shipname = ""
 }
end

SetColorDeflt()

Side = { "bottom", "top", "back", "left", "right" }
for i = 1,5 do
 if (peripheral.getType(Side[i]) == "fluxwarpcore") then
  warp = peripheral.wrap(Side[i])
  break
 end
end

if type(warp) ~= "table" then
 ShowWarning("No warpcore controller detected")
 os.pullEvent("key")
 os.shutdown()
end

if SData.Shipname == "" then
 SetShipName()
end

Title = "<Jump-FW 0.1 \""..SData.Shipname.."\">"

GFront, GBack, GUp, GDown, GLeft, GRight = warp.getBounds()
repeat
 X = 0--warp.get_x()
 sleep(0.3)
until X ~= nil
Y = 0--warp.get_y()
Z = 0--warp.get_z()
Weight = 5--warp.get_ship_size()

CalcRealDistance()

--warp.set_mode(1)

mainloop = true
while(mainloop) do
 Clear()
 ShowInfo()
 term.setCursorPos(1, 15)
 SetColorTitle()
 ShowMenu("D - Dimensions, N - Ship name")
 ShowMenu("S - Set Warp Data, J - Jump")
 ShowMenu("X - Shutdown WarpCore and Exit")
 SetColorDeflt()
 local event, keycode = os.pullEvent("key")
 if keycode == 31 then
  SetDirection()
  SetDistance()
  SaveData()
 elseif keycode == 32 then
  SetDimensions()
  SaveData()
 elseif keycode == 36 then
  rs.setOutput(Alarm, true)
  if Confirm() then
   Warp()
  end
  rs.setOutput(Alarm, false)
 elseif keycode == 45 then
  mainloop = false
 elseif keycode == 49 then
  SetShipName()
 end
end

Clear()
print("good bye")
--warp.set_mode(0)
sleep(0.5)
os.shutdown()